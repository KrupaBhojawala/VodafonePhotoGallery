{"ast":null,"code":"import _toConsumableArray from\"C:\\\\Users\\\\Aditya\\\\Desktop\\\\Krupa\\\\VodafonePhotoGallery\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";// array in local storage for registered users\nvar users=JSON.parse(localStorage.getItem('users'))||[];export function configureFakeBackend(){var realFetch=window.fetch;window.fetch=function(url,opts){return new Promise(function(resolve,reject){// wrap in timeout to simulate server api call\nsetTimeout(function(){// authenticate\nif(url.endsWith('/users/authenticate')&&opts.method==='POST'){// get parameters from post request\nvar params=JSON.parse(opts.body);// find if any user matches login credentials\nvar filteredUsers=users.filter(function(user){return user.staffId===params.staffId&&user.password===params.password;});if(filteredUsers.length){// if login details are valid return user details and fake jwt token\nvar user=filteredUsers[0];var responseJson={id:user.id,staffId:user.staffId,// firstName: user.firstName,\n// lastName: user.lastName,\ntoken:'fake-jwt-token'};resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(responseJson));}});}else{// else return error\nreject('Username or password is incorrect '+filteredUsers.length);}return;}// get users\nif(url.endsWith('/users')&&opts.method==='GET'){// check for fake auth token in header and return users if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(users));}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// get user by id\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='GET'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar urlParts=url.split('/');var id=parseInt(urlParts[urlParts.length-1]);var matchedUsers=users.filter(function(user){return user.id===id;});var _user=matchedUsers.length?matchedUsers[0]:null;// respond 200 OK with user\nresolve({ok:true,text:function text(){return JSON.stringify(_user);}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// register user\nif(url.endsWith('/users/register')&&opts.method==='POST'){// get new user object from post body\nvar newUser=JSON.parse(opts.body);// validation\nvar duplicateUser=users.filter(function(user){return user.staffId===newUser.staffId;}).length;if(duplicateUser){reject('Username \"'+newUser.staffId+'\" is already taken');return;}// save new user\nnewUser.id=users.length?Math.max.apply(Math,_toConsumableArray(users.map(function(user){return user.id;})))+1:1;users.push(newUser);localStorage.setItem('users',JSON.stringify(users));// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});return;}// delete user\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='DELETE'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar _urlParts=url.split('/');var _id=parseInt(_urlParts[_urlParts.length-1]);for(var i=0;i<users.length;i++){var _user2=users[i];if(_user2.id===_id){// delete user\nusers.splice(i,1);localStorage.setItem('users',JSON.stringify(users));break;}}// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// pass through any requests not handled above\nrealFetch(url,opts).then(function(response){return resolve(response);});},500);});};}","map":{"version":3,"sources":["C:/Users/Aditya/Desktop/Krupa/VodafonePhotoGallery/src/FackBackend/fake-backend.js"],"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","staffId","password","length","responseJson","id","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"mappings":"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","sourcesContent":["// array in local storage for registered users\r\nlet users = JSON.parse(localStorage.getItem('users')) || [];\r\n    \r\nexport function configureFakeBackend() {\r\n    let realFetch = window.fetch;\r\n    window.fetch = function (url, opts) {\r\n        return new Promise((resolve, reject) => {\r\n            // wrap in timeout to simulate server api call\r\n            setTimeout(() => {\r\n\r\n                // authenticate\r\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\r\n                    // get parameters from post request\r\n                    let params = JSON.parse(opts.body);\r\n\r\n                    // find if any user matches login credentials\r\n                    let filteredUsers = users.filter(user => {\r\n                        return user.staffId === params.staffId && user.password === params.password;\r\n                    });\r\n\r\n                    if (filteredUsers.length) {\r\n                        // if login details are valid return user details and fake jwt token\r\n                        let user = filteredUsers[0];\r\n                        let responseJson = {\r\n                            id: user.id,\r\n                            staffId: user.staffId,\r\n                            // firstName: user.firstName,\r\n                            // lastName: user.lastName,\r\n                            token: 'fake-jwt-token'\r\n                        };\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\r\n                    } else {\r\n                        // else return error\r\n                        reject('Username or password is incorrect '+filteredUsers.length);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get users\r\n                if (url.endsWith('/users') && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get user by id\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        let matchedUsers = users.filter(user => { return user.id === id; });\r\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\r\n\r\n                        // respond 200 OK with user\r\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // register user\r\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\r\n                    // get new user object from post body\r\n                    let newUser = JSON.parse(opts.body);\r\n\r\n                    // validation\r\n                    let duplicateUser = users.filter(user => { return user.staffId === newUser.staffId; }).length;\r\n                    if (duplicateUser) {\r\n                        reject('Username \"' + newUser.staffId + '\" is already taken');\r\n                        return;\r\n                    }\r\n\r\n                    // save new user\r\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\r\n                    users.push(newUser);\r\n                    localStorage.setItem('users', JSON.stringify(users));\r\n\r\n                    // respond 200 OK\r\n                    resolve({ ok: true, text: () => Promise.resolve() });\r\n\r\n                    return;\r\n                }\r\n\r\n                // delete user\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        for (let i = 0; i < users.length; i++) {\r\n                            let user = users[i];\r\n                            if (user.id === id) {\r\n                                // delete user\r\n                                users.splice(i, 1);\r\n                                localStorage.setItem('users', JSON.stringify(users));\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // respond 200 OK\r\n                        resolve({ ok: true, text: () => Promise.resolve() });\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // pass through any requests not handled above\r\n                realFetch(url, opts).then(response => resolve(response));\r\n\r\n            }, 500);\r\n        });\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}